几种 socket 粘包的解包方式：fix length/delimiter based/length field based frame decoder

1. #### fix length

   每次发送固定缓冲区大小数据.客户端和服务器约定每次发送请求的大小.例如客户端发送 1024 个字节，服务器接受 1024 个字节。
   这样虽然可以解决粘包的问题，但是如果发送的数据小于 1024 个字节，就会导致数据内存冗余和浪费;且如果发送请求大于 1024 字节，会出现半包的问题，也就是数据接收的不完整。

   比如java的netty框架包就支持这种解码方式

2. #### delimiter based

   基于定界符来判断是不是一个请求（例如结尾’\n’). 客户端发送过来的数据，每次以 \n 结束，服务器每接受到一个 \n 就以此作为一个请求.然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包。这种方式的缺点在于如果数据量过大，查找定界符会消耗一些性能

   例如 FTP 协议，将回车换行符作为消息结束符

   

3. length field based

   在 TCP 协议头里面写入每次发送请求的长度。 客户端在协议头里面带入数据长度，服务器在接收到请求后，根据协议头里面的数据长度来决定接受多少数据,只有在读取到足够长度的消息之后才算是读到了一个完整的消息。之后会按照参数指定的包长度偏移量数据对接收到的数据进行解码，从而得到目标消息体数据。

   例如http请求协议，会在header中指定body的长度